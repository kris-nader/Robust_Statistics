}
}
# Our covariance matrix is Theta0 inverted.
S0 <- solve(Theta0)
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
Z <- matrix(rnorm(p*n),p,n)
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
X <- backsolve(U,Z) # more efficient and stable than actually inverting
A <- cov(X)
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
A <- cov(X)
View(A)
View(S0)
? tr
? tr()
? trace()
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,7,M)
M <- 3
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,7,M)
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
source("robust_stat.R")
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
install.packages("huge")
#install.packages("robustbase")
library(robustbase)
library(huge)
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
source("robust_stat.R")
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,M,7)
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
sample.results[i,1] = sample.theta.KL
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
sample.results[i,2] = inv.theta.KL
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
sample.results[i,3] = tws.quad.theta.KL
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
sample.results[i,4] = ths.quad.theta.KL
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
sample.results[i,5] = tws.sp.theta.KL
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
sample.results[i,6] = ths.sp.theta.KL
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
sample.results[i,7] = tws.gauss.theta.KL
}
View(sample.results)
colnames(sample.results) <- c("Glasso", "Sample Covariance", "Twostep Quadrant", "Threestep Quadrant", "Twostep Spearman", "Threestep Spearman", "Gaussian")
View(sample.results)
View(sample.results)
View(sample.results)
write.table(sample.results,file="sample_results_3.txt")
Sys.time()
A <- Sys.time()
B <- Sys.time()
B-A
a <- system.time()
p <- 100
#Theta1 will be an n x p = 50 x 100 matrix
Theta1 <- matrix(0, nrow = p, ncol = p)
for (i in 1:p) {
for (j in 1:p) {
Theta1[i,j] = 0.6^(abs(i-j))
}
}
# Our covariance matrix is Theta1 inverted.
S1 <- solve(Theta1)
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,M,7)
colnames(sample.results) <- c("Glasso", "Sample Covariance", "Twostep Quadrant", "Threestep Quadrant", "Twostep Spearman", "Threestep Spearman", "Gaussian")
A <- Sys.time()
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta1) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta1,sample.theta)
sample.results[i,1] = sample.theta.KL
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta1,inv.theta)
sample.results[i,2] = inv.theta.KL
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta1,tws.quad.theta)
sample.results[i,3] = tws.quad.theta.KL
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta1,ths.quad.theta)
sample.results[i,4] = ths.quad.theta.KL
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta1,tws.sp.theta)
sample.results[i,5] = tws.sp.theta.KL
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta1,ths.sp.theta)
sample.results[i,6] = ths.sp.theta.KL
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta1,tws.gauss.theta)
sample.results[i,7] = tws.gauss.theta.KL
}
B <- Sys.time()
time = B-A
time
source("robust_stat.R")
library(MASS)
p <- 100
#Theta1 will be an n x p = 50 x 100 matrix
Theta1 <- matrix(0, nrow = p, ncol = p)
for (i in 1:p) {
for (j in 1:p) {
Theta1[i,j] = 0.6^(abs(i-j))
}
}
# Our covariance matrix is Theta1 inverted.
S1 <- solve(Theta1)
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,M,7)
colnames(sample.results) <- c("Glasso", "Sample Covariance", "Twostep Quadrant", "Threestep Quadrant", "Twostep Spearman", "Threestep Spearman", "Gaussian")
A <- Sys.time()
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta1) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta1,sample.theta)
sample.results[i,1] = sample.theta.KL
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta1,inv.theta)
sample.results[i,2] = inv.theta.KL
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta1,tws.quad.theta)
sample.results[i,3] = tws.quad.theta.KL
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta1,ths.quad.theta)
sample.results[i,4] = ths.quad.theta.KL
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta1,tws.sp.theta)
sample.results[i,5] = tws.sp.theta.KL
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta1,ths.sp.theta)
sample.results[i,6] = ths.sp.theta.KL
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta1,tws.gauss.theta)
sample.results[i,7] = tws.gauss.theta.KL
}
B <- Sys.time()
time = B-A
time
library("MASS")
source("robust_stat.R")
p <- 100
#Theta1 will be an n x p = 50 x 100 matrix
Theta1 <- matrix(0, nrow = p, ncol = p)
for (i in 1:p) {
for (j in 1:p) {
Theta1[i,j] = 0.6^(abs(i-j))
}
}
# Our covariance matrix is Theta1 inverted.
S1 <- ginv(Theta1)
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,M,7)
colnames(sample.results) <- c("Glasso", "Sample Covariance", "Twostep Quadrant", "Threestep Quadrant", "Twostep Spearman", "Threestep Spearman", "Gaussian")
A <- Sys.time()
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta1) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta1,sample.theta)
sample.results[i,1] = sample.theta.KL
#precision matrix obtained by inverting S
inv.theta <- ginv(S)
inv.theta.KL <- kullback.leibler(Theta1,inv.theta)
sample.results[i,2] = inv.theta.KL
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta1,tws.quad.theta)
sample.results[i,3] = tws.quad.theta.KL
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta1,ths.quad.theta)
sample.results[i,4] = ths.quad.theta.KL
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta1,tws.sp.theta)
sample.results[i,5] = tws.sp.theta.KL
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta1,ths.sp.theta)
sample.results[i,6] = ths.sp.theta.KL
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta1,tws.gauss.theta)
sample.results[i,7] = tws.gauss.theta.KL
}
B <- Sys.time()
time = B-A
time
View(sample.results)
p <- 100
#Theta1 will be an n x p = 50 x 100 matrix
Theta1 <- matrix(0, nrow = p, ncol = p)
for (i in 1:p) {
for (j in 1:p) {
Theta1[i,j] = 0.6^(abs(i-j))
}
}
# Our covariance matrix is Theta1 inverted.
S1 <- ginv(Theta1)
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,M,7)
colnames(sample.results) <- c("Glasso", "Sample Covariance", "Twostep Quadrant", "Threestep Quadrant", "Twostep Spearman", "Threestep Spearman", "Gaussian")
A <- Sys.time()
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta1) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta1,sample.theta)
sample.results[i,1] = sample.theta.KL
#precision matrix obtained by inverting S
inv.theta <- ginv(S)
inv.theta.KL <- kullback.leibler(Theta1,inv.theta)
sample.results[i,2] = inv.theta.KL
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta1,tws.quad.theta)
sample.results[i,3] = tws.quad.theta.KL
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta1,ths.quad.theta)
sample.results[i,4] = ths.quad.theta.KL
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta1,tws.sp.theta)
sample.results[i,5] = tws.sp.theta.KL
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta1,ths.sp.theta)
sample.results[i,6] = ths.sp.theta.KL
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta1,tws.gauss.theta)
sample.results[i,7] = tws.gauss.theta.KL
}
B <- Sys.time()
time = B-A
time
View(sample.results)
