sigma <- matrix(c(1,2,3,4,5,6,7,8,9), nrow=3, byrow=TRUE)
sigma
p <- ncol(sigma)
eig <- eigen(sigma,only.values=T)
const<-abs(min(eig$values,0))
const
eig$values
clear
help pmax
help pmax()
library("robustbase")
help pmax()
? pmax()
sigma <- matrix(c(1,2,3,4,5,6,7,8,9), nrow=3, byrow=TRUE)
eig <- eigen(sigma)
d<-pmax(eig$values,0)
d
Theta0 <- matrix(0, nrow = 50, ncol = 5)
Theta0
Theta0[1]
Theta0[2]
Theta0[[0]]
Theta0[0,0]
Theta0[1,1]
for (i in 1:50) {
for (j in 1:5) {
Theta0[i,j] = 0.6^(abs(i-j))
}
}
Theta0
Theta1 <- matrix(0, nrow = 50, ncol = 100)
for (i in 1:50) {
for (j in 1:100) {
Theta1[i,j] = 0.6^(abs(i-j))
}
}
View(Theta1)
Theta1[:,100]
Theta1[,100]
det(Theta0)
library(MASS)
# Our covariance matrix is Theta0 inverted.
S0 <- ginv(Theta0)
S0%*%Theta0
Theta0%*%S0
# Our covariance matrix is Theta1 inverted.
S1 <- ginv(Theta1)
A <- zapsmall(Theta1%*%S1)
B <- zapsmall(S1%*%Theta1)
View(A)
View(B)
View(Theta1)
source("robust_stat.R")
library(MASS)
#Theta0 will be an n x p = 50 x 5 matrix with Theta_{i,j} = 0.6^abs(i-j)
Theta0 <- matrix(0, nrow = 5, ncol = 5)
for (i in 1:5) {
for (j in 1:5) {
Theta0[i,j] = 0.6^(abs(i-j)) # Makes it banded
}
}
# Our covariance matrix is Theta0 inverted.
S0 <- inv(Theta0)
# Our covariance matrix is Theta0 inverted.
S0 <- solve(Theta0)
#Theta1 will be an n x p = 50 x 100 matrix
Theta1 <- matrix(0, nrow = 100, ncol = 100)
for (i in 1:100) {
for (j in 1:100) {
Theta1[i,j] = 0.6^(abs(i-j))
}
}
# Our covariance matrix is Theta1 inverted.
S1 <- solve(Theta1)
A <- zapsmall(S0)
B <- zapsmall(S1)
View(A)
View(B)
View(S0)
cond(Theta0)
kappa(Theta0)
kappa(Theta1)
? rnorm()
#We will try to estimate a banded precision matrix.
n <- 50
#Theta0 will be a p x p = 5 x 5 matrix with Theta_{i,j} = 0.6^abs(i-j)
p <- 5
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
Z <- matrix(rnorm(p*n), p, n)
View(Z)
U <- chol(Theta0) # By default R's chol returns upper cholesky factor
X <- backsolve(U, Z) # more efficient and stable than actually inverting
View(X)
set.seed(1)
View(X)
source("robust_stat.R")
library(MASS)
set.seed(1)
#We will try to estimate a banded precision matrix.
n <- 50
#Theta0 will be a p x p = 5 x 5 matrix with Theta_{i,j} = 0.6^abs(i-j)
p <- 5
Theta0 <- matrix(0, nrow = p, ncol = p)
for (i in 1:p) {
for (j in 1:p) {
Theta0[i,j] = 0.6^(abs(i-j)) # Makes it banded
}
}
# Our covariance matrix is Theta0 inverted.
S0 <- solve(Theta0)
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
Z <- matrix(rnorm(p*n),p,n)
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
X <- backsolve(U,Z) # more efficient and stable than actually inverting
A <- cov(X)
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
A <- cov(X)
View(A)
View(S0)
? tr
? tr()
? trace()
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,7,M)
M <- 3
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,7,M)
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
source("robust_stat.R")
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
install.packages("huge")
#install.packages("robustbase")
library(robustbase)
library(huge)
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
source("robust_stat.R")
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
}
# We sample by using X = mu + (U_Theta)^-1 Z
# Here mu stands for the mean and will be zero, Z stands for the standard
# multivariate normal distribution and U_Theta stands for the
# Upper triangular matrix in the Cholesky decomposition of Theta:
# Theta = L_Theta%*%U_Theta (L_Theta = t(U_Theta))
sample.results<-matrix(0,M,7)
for (i in 1:M) {
Z <- matrix(rnorm(p*n),p,n) #p*n standarnormal samples in a pxn matrix
U <- chol(Theta0) # By default R's chol returns upper Cholesky factor
# The following is one sample (we need M)
X <- t(backsolve(U,Z)) # more efficient and stable than actually inverting
#glasso based on sample covariance matrix
S <- cov(X)
sample.theta <- theta.sparse(S, n)
sample.theta.KL <- kullback.leibler(Theta0,sample.theta)
sample.results[i,1] = sample.theta.KL
#precision matrix obtained by inverting S
inv.theta <- solve(S)
inv.theta.KL <- kullback.leibler(Theta0,inv.theta)
sample.results[i,2] = inv.theta.KL
#twostep quadrant
twostep.quadrant <- quadrant.untransformed(X)
tws.quad.theta <- theta.sparse(twostep.quadrant,n)
tws.quad.theta.KL <- kullback.leibler(Theta0,tws.quad.theta)
sample.results[i,3] = tws.quad.theta.KL
#threestep quadrant npd
threestep.quadrant <- quadrant.transformed(X, method="npd")
ths.quad.theta <- theta.sparse(threestep.quadrant, n)
ths.quad.theta.KL <- kullback.leibler(Theta0,ths.quad.theta)
sample.results[i,4] = ths.quad.theta.KL
#twostep spearman
twostep.spearman <- spearman.untransformed(X)
tws.sp.theta <- theta.sparse(twostep.spearman, n)
tws.sp.theta.KL <- kullback.leibler(Theta0,tws.sp.theta)
sample.results[i,5] = tws.sp.theta.KL
#threestep spearman
threestep.spearman <- spearman.transformed(X, method="npd")
ths.sp.theta <- theta.sparse(threestep.spearman, n)
ths.sp.theta.KL <- kullback.leibler(Theta0,ths.sp.theta)
sample.results[i,6] = ths.sp.theta.KL
#Gaussian
twostep.gaussian <- Grank(X)
tws.gauss.theta <- theta.sparse(twostep.gaussian, n)
tws.gauss.theta.KL <- kullback.leibler(Theta0,tws.gauss.theta)
sample.results[i,7] = tws.gauss.theta.KL
}
View(sample.results)
colnames(sample.results) <- c("Glasso", "Sample Covariance", "Twostep Quadrant", "Threestep Quadrant", "Twostep Spearman", "Threestep Spearman", "Gaussian")
View(sample.results)
